"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmCompiler = exports.BinaryCompiler = void 0;
exports.compile = compile;
const binary_1 = require("./binary");
const npm_1 = require("./npm");
const errors_1 = require("../errors");
const chalk_1 = __importDefault(require("chalk"));
async function compile(resolcConfig, input) {
    let compiler;
    if (resolcConfig.compilerSource === 'binary') {
        if (resolcConfig.settings?.solcPath === null) {
            throw new errors_1.ResolcPluginError('resolc executable is not specified');
        }
        compiler = new BinaryCompiler(resolcConfig);
    }
    else if (resolcConfig.compilerSource === 'npm') {
        if (resolcConfig.settings?.batchSize)
            console.warn(chalk_1.default.yellow('Batch compilation is only available for `binary` source.\nSetting batchSize will be ignored.'));
        compiler = new NpmCompiler(resolcConfig);
    }
    else {
        throw new errors_1.ResolcPluginError(`Incorrect compiler source: ${resolcConfig.compilerSource}`);
    }
    return await compiler.compile(input, resolcConfig);
}
class BinaryCompiler {
    config;
    constructor(config) {
        this.config = config;
    }
    async compile(input) {
        return await (0, binary_1.compileWithBinary)(input, this.config);
    }
}
exports.BinaryCompiler = BinaryCompiler;
class NpmCompiler {
    config;
    constructor(config) {
        this.config = config;
    }
    async compile(input) {
        return await (0, npm_1.compileWithNpm)(input);
    }
}
exports.NpmCompiler = NpmCompiler;
//# sourceMappingURL=index.js.map