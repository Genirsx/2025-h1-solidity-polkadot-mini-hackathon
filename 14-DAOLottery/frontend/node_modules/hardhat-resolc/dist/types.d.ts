import { CompilerInput, SolcConfig } from 'hardhat/types';
type EvmVersions = 'homestead' | 'tangerineWhistle' | 'spuriousDragon' | 'byzantium' | 'constantinople' | 'petersburg' | 'istanbul' | 'berlin' | 'london' | 'paris' | 'shanghai' | 'cancun';
type CombinedJSONOpts = 'abi' | 'hashes' | 'metadata' | 'devdoc' | 'userdoc' | 'storage-layout' | 'ast' | 'asm' | 'bin' | 'bin-runtime';
type SuppresWarningsOpts = 'ecrecover' | 'sendtransfer' | 'extcodesize' | 'txorigin' | 'blocktimestamp' | 'blocknumber' | 'blockhash';
export interface ResolcConfig {
    version: string;
    compilerSource?: 'binary' | 'npm';
    settings?: {
        basePath?: string;
        includePaths?: string[];
        allowPaths?: string;
        outputDir?: string;
        overwrite?: boolean;
        optimizer?: {
            enabled?: boolean;
            parameters?: '0' | '1' | '2' | '3' | 's' | 'z';
            fallbackOz?: boolean;
        };
        solcPath?: string;
        evmVersion?: EvmVersions;
        combinedJson?: CombinedJSONOpts;
        standardJson?: boolean;
        detectMissingLibraries?: boolean;
        yul?: boolean;
        llvmIR?: boolean;
        forceEVMLA?: boolean;
        metadataHash?: string;
        asm?: boolean;
        bin?: boolean;
        suppressWarnings?: SuppresWarningsOpts[];
        debugOutputDir?: string;
        llvmVerifyEach?: boolean;
        llvmDebugLogging?: boolean;
        compilerPath?: string;
        contractsToCompile?: string[];
        emitDourceDebugInfo?: boolean;
        libraries?: string[];
        disableSolcOptimizer?: boolean;
        fallbackToOptimizingForSize?: boolean;
        batchSize?: number;
    };
}
export interface ReviveCompilerInput extends CompilerInput {
    suppressedWarnings?: string[];
    suppressedErrors?: string[];
}
export interface MissingLibrary {
    contractName: string;
    contractPath: string;
    missingLibraries: string[];
}
export interface SolcConfigData {
    compiler: SolcConfig;
    file?: string;
}
export interface ContractBatch {
    [key: string]: object | string;
}
export interface ContractSource {
    [key: string]: object;
}
export interface Sources {
    [key: string]: {
        id: number;
        ast: object;
    };
}
export interface CompiledOutput {
    contracts: ContractSource;
    sources: Sources;
    errors: string[];
    version: string;
    long_version: string;
    revive_version: string;
}
export {};
